<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Ram Lalla</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/ScrollTrigger.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        overscroll-behavior: none;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
      }

      #loader {
        transition: opacity 0.6s ease-out;
      }

      #hint {
        transition: opacity 0.8s ease-out;
      }

      canvas {
        display: block;
      }
    </style>
  </head>

  <body class="bg-black">
    <!-- Loading screen -->
    <div
      id="loader"
      class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black"
    >
      <h2 class="text-white text-xl font-light tracking-widest mb-8 uppercase">
        Ram Lalla
      </h2>
      <div class="w-48 h-[2px] bg-white/20 rounded-full overflow-hidden">
        <div
          id="progressBar"
          class="h-full bg-white rounded-full transition-all duration-150 ease-out"
          style="width: 0%"
        ></div>
      </div>
      <p
        id="progressText"
        class="text-white/60 text-sm mt-4 font-light tracking-wider"
      >
        Loading...
      </p>
    </div>

    <!-- Scroll container -->
    <div id="scrollContainer">
      <canvas id="frameCanvas"></canvas>
    </div>

    <!-- Scroll hint -->
    <h1
      id="hint"
      class="z-10 fixed bottom-5 left-5 text-xs font-medium text-white bg-black/30 backdrop-blur-sm rounded-full px-2.5 py-1.5"
      style="opacity: 0"
    >
      Scroll to explore
    </h1>

    <script type="module">
      import {
        Input,
        ALL_FORMATS,
        BlobSource,
        VideoSampleSink,
      } from "https://esm.sh/mediabunny@latest";

      gsap.registerPlugin(ScrollTrigger);

      const SCROLL_HEIGHT_VH = 500;
      const VIDEO_SRC = "/assets/video.mp4";

      const canvas = document.getElementById("frameCanvas");
      const ctx = canvas.getContext("2d");
      const loader = document.getElementById("loader");
      const progressBar = document.getElementById("progressBar");
      const progressText = document.getElementById("progressText");
      const hint = document.getElementById("hint");
      const scrollContainer = document.getElementById("scrollContainer");

      let videoDuration = 0;
      let frames = [];
      let totalFrames = 0;
      let currentFrameIndex = 0;

      function sizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function drawFrame(index) {
        const sample = frames[index];
        if (!sample) return;

        const cw = canvas.width;
        const ch = canvas.height;
        const vw = sample.displayWidth || sample.width;
        const vh = sample.displayHeight || sample.height;
        if (!vw || !vh) return;

        const scale = Math.max(cw / vw, ch / vh);
        const dw = vw * scale;
        const dh = vh * scale;
        const dx = (cw - dw) / 2;
        const dy = (ch - dh) / 2;

        ctx.clearRect(0, 0, cw, ch);
        sample.draw(ctx, dx, dy, dw, dh);
      }

      async function fetchVideoBlob() {
        progressText.textContent = "Fetching video...";
        const response = await fetch(VIDEO_SRC);
        if (!response.ok) {
          throw new Error(`Failed to fetch video: ${response.status}`);
        }

        const totalBytes = parseInt(
          response.headers.get("content-length") || "0"
        );
        let loadedBytes = 0;

        const reader = response.body?.getReader();
        const chunks = [];

        if (reader) {
          // Stream with progress if supported
          // (Some environments may not support streaming; we handle that gracefully.)
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            loadedBytes += value.length;

            if (totalBytes > 0) {
              const pct = Math.round((loadedBytes / totalBytes) * 70); // up to 70% during fetch
              progressBar.style.width = `${pct}%`;
              progressText.textContent = `${pct}%`;
            }
          }
          return new Blob(chunks);
        }

        // Fallback: no streaming reader, just fetch blob
        const blob = await response.blob();
        progressBar.style.width = "70%";
        progressText.textContent = "70%";
        return blob;
      }

      async function decodeFrames(blob) {
        progressText.textContent = "Decoding frames...";

        const input = new Input({
          formats: ALL_FORMATS,
          source: new BlobSource(blob),
        });

        const videoTrack = await input.getPrimaryVideoTrack();
        if (!videoTrack) {
          throw new Error("No video track found");
        }

        const decodable = await videoTrack.canDecode();
        if (!decodable) {
          throw new Error("Video cannot be decoded in this browser");
        }

        videoDuration = await videoTrack.computeDuration();

        const sink = new VideoSampleSink(videoTrack);
        frames = [];

        let lastPct = 70; // continue from fetch progress

        for await (const sample of sink.samples(0, videoDuration)) {
          frames.push(sample);

          if (videoDuration > 0 && typeof sample.timestamp === "number") {
            const decodePct =
              70 + Math.round((sample.timestamp / videoDuration) * 30); // 70%â€“100%
            if (decodePct !== lastPct) {
              lastPct = decodePct;
              progressBar.style.width = `${Math.min(decodePct, 100)}%`;
              progressText.textContent = `${Math.min(decodePct, 100)}%`;
            }
          }
        }

        totalFrames = frames.length;
        if (!totalFrames) {
          throw new Error("No frames decoded from video");
        }

        progressBar.style.width = "100%";
        progressText.textContent = "100%";
      }

      async function loadAndDecodeVideo() {
        try {
          const blob = await fetchVideoBlob();
          await decodeFrames(blob);
          return true;
        } catch (error) {
          console.error("Error loading/decoding video:", error);
          progressText.textContent = `Error: ${error.message}`;
          return false;
        }
      }

      function hideLoader() {
        loader.style.opacity = "0";
        setTimeout(() => {
          loader.style.display = "none";
        }, 600);
      }

      function showHint() {
        hint.style.opacity = "1";
      }

      function initScrollAnimation() {
        scrollContainer.style.height = `${SCROLL_HEIGHT_VH}vh`;
        canvas.style.position = "fixed";
        canvas.style.top = "0";
        canvas.style.left = "0";

        const frameObj = { value: 0 };

        gsap.to(frameObj, {
          value: totalFrames - 1,
          ease: "none",
          scrollTrigger: {
            trigger: scrollContainer,
            start: "top top",
            end: "bottom bottom",
            scrub: 0.5,
            onUpdate: (self) => {
              const idx = Math.round(self.progress * (totalFrames - 1));
              if (idx !== currentFrameIndex) {
                currentFrameIndex = idx;
                drawFrame(currentFrameIndex);
              }
            },
          },
        });

        gsap.to(hint, {
          opacity: 0,
          scrollTrigger: {
            trigger: scrollContainer,
            start: "top top",
            end: "5% top",
            scrub: true,
          },
        });
      }

      async function init() {
        sizeCanvas();

        const ok = await loadAndDecodeVideo();
        if (!ok) return;

        // Draw the first frame (old image-sequence style)
        drawFrame(0);
        hideLoader();

        requestAnimationFrame(() => {
          showHint();
          initScrollAnimation();
        });

        window.addEventListener("resize", () => {
          sizeCanvas();
          drawFrame(currentFrameIndex);
          ScrollTrigger.refresh();
        });
      }

      init();
    </script>
  </body>
</html>
